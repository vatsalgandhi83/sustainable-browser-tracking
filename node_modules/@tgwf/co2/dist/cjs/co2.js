"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var co2_exports = {};
__export(co2_exports, {
  CO2: () => CO2,
  default: () => co2_default
});
module.exports = __toCommonJS(co2_exports);
var import_byte = __toESM(require("./1byte.js"));
var import_sustainable_web_design_v3 = __toESM(require("./sustainable-web-design-v3.js"));
var import_sustainable_web_design_v4 = __toESM(require("./sustainable-web-design-v4.js"));
var import_helpers = require("./helpers/index.js");
class CO2 {
  constructor(options) {
    this.model = new import_sustainable_web_design_v3.default();
    if ((options == null ? void 0 : options.model) === "1byte") {
      this.model = new import_byte.default();
    } else if ((options == null ? void 0 : options.model) === "swd") {
      this.model = new import_sustainable_web_design_v3.default();
      if ((options == null ? void 0 : options.version) === 4) {
        this.model = new import_sustainable_web_design_v4.default();
      }
    } else if (options == null ? void 0 : options.model) {
      throw new Error(
        `"${options.model}" is not a valid model. Please use "1byte" for the OneByte model, and "swd" for the Sustainable Web Design model.
See https://developers.thegreenwebfoundation.org/co2js/models/ to learn more about the models available in CO2.js.`
      );
    }
    if ((options == null ? void 0 : options.rating) && typeof options.rating !== "boolean") {
      throw new Error(
        `The rating option must be a boolean. Please use true or false.
See https://developers.thegreenwebfoundation.org/co2js/options/ to learn more about the options available in CO2.js.`
      );
    }
    const allowRatings = !!this.model.allowRatings;
    this._segment = (options == null ? void 0 : options.results) === "segment";
    this._rating = (options == null ? void 0 : options.rating) === true;
    if (!allowRatings && this._rating) {
      throw new Error(
        `The rating system is not supported in the model you are using. Try using the Sustainable Web Design model instead.
See https://developers.thegreenwebfoundation.org/co2js/models/ to learn more about the models available in CO2.js.`
      );
    }
  }
  /**
   * Accept a figure in bytes for data transfer, and a boolean for whether
   * the domain shows as 'green', and return a CO2 figure for energy used to shift the corresponding
   * the data transfer.
   *
   * @param {number} bytes
   * @param {boolean} green
   * @return {number|CO2EstimateComponentsPerByte} the amount of CO2 in grammes or its separate components
   */
  perByte(bytes, green = false) {
    return this.model.perByte(bytes, green, this._segment, this._rating);
  }
  /**
   * Accept a figure in bytes for data transfer, and a boolean for whether
   * the domain shows as 'green', and return a CO2 figure for energy used to shift the corresponding
   * the data transfer.
   *
   * @param {number} bytes
   * @param {boolean} green
   * @return {number|CO2EstimateComponentsPerVisit} the amount of CO2 in grammes or its separate components
   */
  perVisit(bytes, green = false) {
    var _a;
    if ((_a = this.model) == null ? void 0 : _a.perVisit) {
      return this.model.perVisit(bytes, green, this._segment, this._rating);
    } else {
      throw new Error(
        `The perVisit() method is not supported in the model you are using. Try using perByte() instead.
See https://developers.thegreenwebfoundation.org/co2js/methods/ to learn more about the methods available in CO2.js.`
      );
    }
  }
  /**
   * Accept a figure in bytes for data transfer, a boolean for whether
   * the domain shows as 'green', and an options object.
   * Returns an object containing CO2 figure, green boolean, and object of the variables used in calculating the CO2 figure.
   *
   * @param {number} bytes
   * @param {boolean} green
   * @param {Object} options
   * @return {CO2EstimateTraceResultPerByte} the amount of CO2 in grammes
   */
  perByteTrace(bytes, green = false, options = {}) {
    const adjustments = (0, import_helpers.parseByteTraceOptions)(
      options,
      this.model.version,
      green
    );
    const { gridIntensity, ...traceVariables } = adjustments;
    const {
      dataReloadRatio,
      firstVisitPercentage,
      returnVisitPercentage,
      ...otherVariables
    } = traceVariables;
    return {
      co2: this.model.perByte(
        bytes,
        green,
        this._segment,
        this._rating,
        adjustments
      ),
      green,
      variables: {
        description: "Below are the variables used to calculate this CO2 estimate.",
        bytes,
        gridIntensity: {
          description: "The grid intensity (grams per kilowatt-hour) used to calculate this CO2 estimate.",
          ...adjustments.gridIntensity
        },
        ...otherVariables
      }
    };
  }
  /**
   * Accept a figure in bytes for data transfer, a boolean for whether
   * the domain shows as 'green', and an options object.
   * Returns an object containing CO2 figure, green boolean, and object of the variables used in calculating the CO2 figure.
   *
   * @param {number} bytes
   * @param {boolean} green
   * @param {Object} options
   * @return {CO2EstimateTraceResultPerVisit} the amount of CO2 in grammes
   */
  perVisitTrace(bytes, green = false, options = {}) {
    var _a;
    if ((_a = this.model) == null ? void 0 : _a.perVisit) {
      const adjustments = (0, import_helpers.parseVisitTraceOptions)(
        options,
        this.model.version,
        green
      );
      const { gridIntensity, ...variables } = adjustments;
      return {
        co2: this.model.perVisit(
          bytes,
          green,
          this._segment,
          this._rating,
          adjustments
        ),
        green,
        variables: {
          description: "Below are the variables used to calculate this CO2 estimate.",
          bytes,
          gridIntensity: {
            description: "The grid intensity (grams per kilowatt-hour) used to calculate this CO2 estimate.",
            ...adjustments.gridIntensity
          },
          ...variables
        }
      };
    } else {
      throw new Error(
        `The perVisitTrace() method is not supported in the model you are using. Try using perByte() instead.
See https://developers.thegreenwebfoundation.org/co2js/methods/ to learn more about the methods available in CO2.js.`
      );
    }
  }
  SustainableWebDesignV3() {
    return new import_sustainable_web_design_v3.default();
  }
  SustainableWebDesignV4() {
    return new import_sustainable_web_design_v4.default();
  }
  OneByte() {
    return new import_byte.default();
  }
}
var co2_default = CO2;
//# sourceMappingURL=co2.js.map
